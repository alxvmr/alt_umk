\hypertarget{4}{\chapter{Инструмент Gear}}\label{chapter-gear}
\Emph{GEAR (Get Every Archive from git package Repository)} --- 
инструмент для поддержки и сборки пакетов из \Sys{git}-репозиториев%
\footnote{\href{https://www.altlinux.org/Gear}{https://www.altlinux.org/Gear}}%
\footnote{\href{https://www.altlinux.org/Gear/\%D0\%A1\%D0\%BF\%D1\%80\%D0\%B0\%D0\%B2\%D0\%BE\%D1\%87\%D0\%BD\%D0\%B8\%D0\%BA}{https://www.altlinux.org/Gear/Справочник}}.

\marginalia{ex_sign_col}{Для работы с текущим разделом необходимо изучить 
документацию по работе с распределённой системой управления версиями \Sys{Git}.}

\Emph{Git} --- это технология контроля версий, которая следит за изменениями в файлах. 
\Sys{Git}-репозиторий хранит исходный код и данные для сборки пакетов, включая историю 
изменений, сведения о версиях, авторах изменений и прочую информацию. 

При сборке пакетов \Sys{gear} предлагает работать в том же \Sys{git}-репозитории, 
в котором хранятся исходные тексты пакета. \Sys{Gear} позволяет целиком импортировать 
историю разработки, предоставляет различные средства импорта исходных текстов и 
различные варианты организации репозитория. 

Идея \Sys{gear} в доступности всего необходимого для сборки пакета в \Sys{git}-репозитории, 
либо в репозитории пакетов, на основе которого ведётся сборка. Система контроля версий 
\Sys{Git} предоставляет встроенные механизмы обеспечения целостности (контрольные суммы, 
криптографически подписанные теги) для задач управления пакетами. Появляется возможность 
воспроизводимой сборки --- собрать <<такой же>> пакет ещё раз, опираясь на логически 
законченную версию изменений зафиксированную на момент времени --- коммит (commit) в 
терминологии git.

Сборка пакета ведётся из конкретного коммита, который мы в дальнейшем будем называть главным. 
Именно в нём должна находится нужная версия \Sys{SPEC}-файла и правил экспорта. \Sys{GEAR} 
позволяет экспортировать из \Sys{git}-репозитория каталоги и подкаталоги в виде архивов; 
экспортировать отдельные файлы; вычислять разницу (\Sys{diff}) и сохранять её в виде патча. 
При этом может использоваться как состояние в главном коммите, так и в любом из его предков, 
прямых и не прямых. Это позволяет гибко и удобно организовать работу по поддержке пакета: 
все нужные исходные тексты можно хранить в \Sys{git} так, чтобы с ними было удобно работать, 
а затем экспортировать так, чтобы ими было удобно воспользоваться из \Sys{SPEC}-файла.

Правила экспорта для \Sys{gear} описываются в текстовом файле, который также хранится в 
репозитории. По умолчанию \Sys{gear} ищет этот файл по пути \Sys{.gear/rules} или \Sys{.gear-rules}. 
Подробнее про синтаксис этого файла можно прочитать ниже, в разделе <<Правила экспорта>>.

Для удобства сборки пакетов \Sys{gear} интегрирован с инструментами \Sys{rpm-build} и 
\Sys{hasher}: из \Sys{gear}-репозитория можно одной командой собрать пакет при помощи 
\Sys{rpmbuild} или \Sys{hsh}. Подробнее об этом можно прочитать далее в разделе <<Быстрый старт>>. 


\section{Структура репозитория}
Обобщим опыт, упрощающий работу с \Sys{git}-репозиториями, предназначенными для хранения исходного кода пакетов. 

\begin{itemize}
	\item \Emph{Одна кодовая база --- один репозиторий.}
	
	Не имеет смысла хранить в одном репозитории исходные тексты, не связанных между собой пакетов. 
		В этом правиле бывают исключения в случае, если культура разработки предполагает хранение 
		разных составных частей проекта в одном репозитории.
	\item  \Emph{Храните в \Sys{git}-репозитории распакованный исходный код.}
	
	Исходные тексты, поставляемые в виде архивов (\Sys{tar}, \Sys{zip}) и сжатые различными 
		компрессорами (\Sys{gz}, \Sys{bzip2}, \Sys{xz}) удобнее распаковать. Это упрощает 
		использование средств \Sys{git} для работы с этими данными: так легче отслеживать изменения, 
		ниже трафик при обновлениях и~т.\,д.
	\item \Emph{Отделяйте свои изменения от изменений исходной кодовой базы.}
	
	Если вы не являетесь разработчиком пакета, который собираете, лучше хранить свои изменения отдельно 
		от кода разработчиков, например в отдельной ветке (и формировать \Sys{diff} средствами \Sys{GEAR}) 
		или в виде патчей. Это заметно упрощает совместную работу над пакетом, обновления и аудит.
\end{itemize}


\section{Правила экспорта}
Правила экспорта для \Sys{GEAR} описываются в текстовом файле, который также хранится в репозитории. 
По умолчанию \Sys{GEAR} ищет этот файл по пути \Sys{.gear/rules} или \Sys{.gear-rules}, от корня репозитория, 
в главном коммите. 

Этот файл состоит из одной или нескольких строк, каждая из которых имеет следующий формат: \verb!<директива>: <параметры>!

Параметры разделяются пробельными символами. Пробелы между директивой и <<:>> и <<:>> и параметрами 
не обязательны. 

Пустые строки и строки, начинающиеся с <<\#>>, игнорируются. 

В значениях многих параметров и опций директив могут применяться ключевые слова: 
\begin{itemize}
	\item \Sys{@name@} --- будет заменено на имя пакета (извлекается из \Sys{SPEC}-файла);
	\item \Sys{@version@} --- будет заменено на версию пакета (извлекается из \Sys{SPEC}-файла);
	\item \Sys{@release@} --- будет заменено на релиз пакета (извлекается из \Sys{SPEC}-файла).
\end{itemize}

\Emph{Теги и пути}

По умолчанию все пути в аргументах директив считаются от корня репозитория главного коммита. 
Однако большинство директив позволяет указать другой коммит в качестве основы. Для этого путь 
должен быть передан в формате: 
\begin{verbatim}
	base_tree:path_to_file.
\end{verbatim}

В качестве \Sys{base\_tree} может выступать: 
\begin{itemize}
	\item полный идентификатор коммита (\Sys{SHA-1}, 40 шестнадцатиричных цифр);
	\item имя тега \Sys{GEAR};
	\item символ <<.>>, обозначающий главный коммит.
\end{itemize}

В любом случае, коммит, на который так ссылаются, должен быть предком главного коммита. 

\Emph{Основные директивы}

Ниже приведены основные директивы \Sys{GEAR}, и их аргументы. Подробнее с ними можно 
ознакомиться в \Sys{man gear-rules(5)}.

\begin{itemize}
	\item \Emph{\Sys{spec: <путь> }}
	
	Задаёт путь к \Sys{SPEC}-файлу. По умолчанию, \Sys{GEAR} использует файл с 
		расширением \Sys{.spec} из корня репозитория в главном коммите, 
		если такой файл там только один. Единственный аргумент --- путь к \Sys{SPEC}-файлу.
	
	\item \Emph{\Sys{copy: <glob>...}}
	Скопировать файл, соответствующий указанному шаблону поиска (glob pattern). 
		Может принимать несколько аргументов, для каждого из которых должны 
		быть найдены соответствующие файлы.
	
	Также существуют директивы \Sys{gzip}, \Sys{bzip2}, \Sys{lzma}, \Sys{lzma}, \Sys{zstd}, 
		аналогичные copy, но сжимающие экспортированный файл подходящим алгоритмом сжатия.
	\item  \Emph{\Sys{tar: <tree\_path>}}

	Экспортировать каталог из репозитория в виде \Sys{tar}-архива. Допустимые опции: 
	\begin{itemize}
		\item \Sys{name=<archive\_name>} имя архива (без суффикса \Sys{.tar});
		\item \Sys{base=<base\_name>} внутри архива будет создан каталог с указанным именем, 
			и все файлы будут помещены в него;
		\item \Sys{suffix=<suffix>} расширение создаваемого архива (по умолчанию --- \Sys{.tar});
		\item \Sys{exclude=<glob\_patter>} не включать в архив файлы, соответствующие указанному шаблону поиска.
	\end{itemize}
	
	Помимо стандартных ключевых слов, в опциях \Sys{name} и \Sys{base} может применяться ключевое 
		слово \Sys{@dir@}, которое будет заменено на имя каталога из параметра \Sys{tree\_path}. 
	\item \Emph{\Sys{zip: <tree\_path>}}
	
	Экспортировать каталог из репозитория в виде \Sys{zip}-архива. Принимает те же аргументы, 
		что и директива \Sys{tar}, использует \Sys{.zip} в качестве расширения по умолчанию. 
	
	Также существуют директивы \Sys{tar.gz, tar.bz2, tar.lzma, tar.xz, tar.zst}, аналогичные 
		\Sys{tar}, но сжимающие созданный архив подходящим алгоритмом сжатия. Чаще всего используются 
		несжатые архивы, так как сжатия, используемого при сборке \Sys{SRPM}, обычно достаточно.
	\item  \Emph{\Sys{diff: <old\_tree\_path> <new\_tree\_path>}}
	
	Создать \Sys{unified diff} между указанными каталогами и сохранить его в виде патча. Допустимые опции:
	\begin{itemize}
		\item \Sys{name=<diff\_name>} имя создаваемого файла;
		\item \Sys{exclude=<glob\_patter>} игнорировать файлы, соответствующие указанному шаблону поиска.
	\end{itemize}
	
	Помимо стандартных ключевых слов, в опции \Sys{name} могут применяться ключевые слова \Sys{@old\_dir@} 
		и \Sys{@new\_dir@}, которые будут заменены на имя каталога из параметра \Sys{old\_tree\_path} 
		и \Sys{new\_tree\_path} соответственно. 
\end{itemize}

Все приведённые директивы требуют, чтобы все указанные в них файлы и каталоги существовали; если какого-то 
файла или каталога не будет существовать, экспорт завершится ошибкой. Однако существуют аналогичные им директивы, 
заканчивающиеся знаком вопроса (например, \Sys{tar?:} или \Sys{copy?:}), которые игнорируют отсутствующие файлы. 
Это может быть удобно, чтобы не приходилось менять правила экспорта при добавлении и удалении патчей.


\section{Основные типы устройства \Sys{gear}-репозитория}
Гибкость \Sys{GEAR}\footnote{\href{https://www.altlinux.org/\%D0\%A0\%D1\%83\%D0\%BA\%D0\%BE\%D0\%B2\%D0\%BE\%D0\%B4\%D1\%81\%D1\%82\%D0\%B2\%D0\%BE_\%D0\%BF\%D0\%BE_gear}{https://www.altlinux.org/Руководство\_по\_gear}} 
означает, что каждый пользователь может настроить его по своему усмотрению. Существует несколько 
распространённых способов организации \Sys{gear}-репозитория в качестве основы для более сложных конфигураций. 
Знакомство с ними поможет понять организацию репозитория при совместной работе над пакетами. 

Базовые виды ведения \Sys{GEAR} репозиториев:
\begin{itemize}
	\item \Emph{Архив с исходными текстами и патчи.}
	
	Исходные тексты хранятся в каталоге \Sys{package\_name}; дополнительные изменения хранятся в виде патчей. 
		Подобные репозитории создаёт команда \Sys{gear-srpmimport}, и также выглядят импортированные 
		пакеты в \Sys{git.altlinux.org/srpms}.
	
	В каталоге \Sys{package\_name} принято хранить не изменённые исходники; для их обновления удобно 
		использовать команду \Sys{gear-update}.
	
	Такой формат будет больше всего знаком пользователям без опыта поддержки пакетов \Sys{source RPM}, 
		и при работе с проектами, не имеющими публичного \Sys{git}-репозитория или не использующими \Sys{git}.
	
	Пример \Sys{.gear/rules}:
	\begin{verbatim}
		tar: package_name
		copy?: *.patch
	\end{verbatim} 
	
	\item \Emph{Репозиторий с историей исходного репозитория и модифицированными исходными текстами.}
	
	Создаётся копия исходного \Sys{git}-репозитория. Находится коммит, из которого нужно взять исходные 
		тексты для сборки. На основе этого коммита добавляется каталог \Sys{.gear} и \Sys{SPEC}-файл. 
		При обновлении новые исходные тексты сливаются (\Sys{merge}) в эту ветку. Создаётся \Sys{gear}-тег, 
		соответствующий собираемой версии. Изменения могут храниться в виде патчей. Но чаще вносятся в 
		текущую ветку со \Sys{spec}-файлом, затем изменения экспортируются в виде одного большого патча. 
	
	Пример \Sys{.gear/rules} с генерацией патча:
	\begin{verbatim}
		tar: v@version@:.
		diff: v@version@:. . exclude=.gear/** exclude=*.sp
	\end{verbatim}
	
	\item \Emph{Пустая ветка со \Sys{SPEC}-файлом и отдельная история разработки.}
	
	Изначально \Sys{SPEC}-файл и \Sys{.gear} ведутся в отдельной ветке, содержащей главный коммит. 
		Исходные тексты, необходимые для сборки пакета, сливаются (\Sys{merge}) при необходимости 
		с \Sys{git} стратегией \Sys{ours} --- таким образом, нужные коммиты оказываются в истории 
		главного, но сами исходные тексты в ветку не попадают. Если нужно внести какие-то специфичные 
		изменения, они вносятся в отдельную ветку, например \Sys{alt-fixes}. При каждом обновлении 
		кода ветка \Sys{alt-fixes} и соответствующий ей \Sys{GEAR}-тег должны обновляться. В нашем 
		примере \Sys{GEAR}-тег совпадает с именем ветки. 
	
	Пример \Sys{.gear/rules}:
	\begin{verbatim}
		tar: v@version@:.
		diff: v@version@:. alt-fixes:.
	\end{verbatim} 
\end{itemize}


\section{Быстрый старт Gear}
\Emph{Установка gear}

В разделе \hyperlink{1.3}{<<Установка необходимых пакетов для процесса сборки>>} 
также упоминается инструмент \Sys{gear}. Для отдельной установки используйте команду: 
\begin{verbatim}
	#apt-get install gear
\end{verbatim}

\Emph{Импорт .src.rpm }

Пакет в формате \Sys{source RPM} можно импортировать в \Sys{gear}-репозиторий командой \Sys{gear-srpmimport}:
\begin{verbatim}
	mkdir package_name
	cd package_name
	git init -b sisyphus
	gear-srpmimport /путь/к/package_name.src.rpm
\end{verbatim}

\Emph{Получение готового репозитория с внешнего git-сервера}

Достаточно клонировать репозиторий: 
\begin{verbatim}
	git clone <repository url> package_name
	cd package_name
\end{verbatim}

Никаких дополнительных настроек не требуется.

\Emph{Сборка пакета}

Основным инструментом экспорта и сборки пакетов является команда \Sys{gear}. На практике удобно 
использовать предоставляемые команды-обёртки, а к самой команде \Sys{gear} прибегать только в 
самых сложных случаях. Командной обёртке можно передавать опции как утилиты \Sys{gear}, так и 
вложенной утилиты.

Командная обертка \Sys{gear} для \Sys{rpmbuild} --- \Sys{gear-rpm}. Для сборки пакета используйте команду: 
\begin{verbatim}
	gear-rpm --verbose -ba
\end{verbatim}


Собрать пакет при помощи \Sys{hsh} (установка и настройка \Sys{hasher} описана в следующих главах): 
\begin{verbatim}
	gear-hsh --verbose
\end{verbatim}

Команде \Sys{gear-hsh} можно передать как аргументы \Sys{gear}, так и аргументы \Sys{hsh}.

Если не указана опция \Sys{--tree-ish}, \Sys{gear} в качестве главного коммита использует текущий 
коммит (HEAD). Если хочется проверить свежие изменения без создания коммита, можно использовать опцию 
\Sys{--commit}, доступную и для \Sys{gear}, и для \Sys{gear-rpm}, и для \Sys{gear-hsh}. В таком случае 
будет создан временный коммит (аналогично \Sys{git commit -a}), и пакет будет собран уже из него. 
Стоит отметить, что, аналогично \Sys{git commit -a}, в таком коммите не будет новых файлов, если они 
ещё не были добавлены в \Sys{git} командой \Sys{git add}; если они нужны для сборки, то их стоит добавить. 

\Emph{Сборка пакета из репозитория разработчиков}

Для примера возьмём конкретный пакет, который уже есть в репозитории Сизиф, например \Sys{pixz}, и попробуем
собрать его с нуля.

Для начала клонируем репозиторий. Сразу зададим имя удалённого репозитория: 
\begin{verbatim}
	git clone https://github.com/vasi/pixz -o upstream
	cd pixz
\end{verbatim}

Перейдём в ветку, из которой будем собирать пакет: 
\begin{verbatim}
	git checkout -b sisyphus upstream/master
\end{verbatim}

Переместимся на тег (тег --- это ссылка, указывающие на определённый \Sys{git}-коммит в репозитории), 
соответствующий версии, которую мы будем собирать. На момент написания пособия последний тег \Sys{v1.0.7}: 
\begin{verbatim}
	git reset --hard v1.0.7
\end{verbatim}

Определим правила экспорта: 
\begin{verbatim}
	mkdir .gear
	vim .gear/rules
\end{verbatim}

Правила зададим следующие: 
\begin{itemize}
	\item \Sys{SPEC}-файл перенесём в каталог \Sys{.gear}, чтобы он не путался с основными исходными текстами;
	\item исходники будем забирать из тега \Sys{GEAR}, соответствующего апстримному;
	\item сразу создадим патч, включающий все наши изменения, каталог \Sys{.gear} в этот патч мы включать не будем.
\end{itemize}

Получаем следующий файл \Sys{.gear/rules}:
\begin{verbatim}
	spec: .gear/pixz.spec
	tar: v@version@:.
	diff: v@version@:. . exclude=.gear/**
\end{verbatim}

Создадим соответствующий версии тег \Sys{GEAR}:
\begin{verbatim}
	gear-store-tags v1.0.7
\end{verbatim} 

Напишем \Sys{SPEC}-файл:
\begin{verbatim}
	vim .gear/pixz.spec
\end{verbatim} 

Важно, что версия в спеке --- \Sys{1.0.7}, поэтому конструкция \Sys{v@version@}, 
которую мы использовали в \Sys{.gear/rules}, раскроется в строку \Sys{v1.0.7} --- 
именно такой тег \Sys{GEAR} мы создали. 

Добавим каталог \Sys{.gear} в \Sys{git}:
\begin{verbatim}
	git add .gear
\end{verbatim} 

Можно попробовать собрать пакет: 
\begin{verbatim}
	gear-rpm --verbose --commit -ba
\end{verbatim}

При необходимости, можно поправить \Sys{spec}, добавить нужные зависимости. 
Когда пакет собирается и всем устраивает, можно зафиксировать все изменения: 
\begin{verbatim}
	gear-commit -a
\end{verbatim}

\section{Вопросы для самопроверки}

\begin{enumerate}
	\item Что такое инструмент \Sys{git}?
	\item Что такое инструмент \Sys{gear}?
	\item Где хранятся правила экспорта для \Sys{gear}?
	\item Перечислете правила, упрощающие работу с \Sys{git}-репозиториями?
	\item Какой формат у файла с правилами экспорта для \Sys{gear}?
	\item Что означает параметр \Sys{@name@} в файле \Sys{.gear-rules}?
	\item Как формируется путь в аргументах директив в файле \Sys{.gear-rules}?
        \item Перечислите основные дерективы в файле \Sys{.gear-rules}?
	\item Какой командой собирается пакет с помощью \Sys{gear}?
        \item Как создать тег соответствующий версии пакета с помощью \Sys{gear}?
\end{enumerate}
